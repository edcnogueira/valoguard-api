# Project Guidelines

## Commands

### `generate`

This will regenerate all the code that is generated by the project. This includes SQLC, mocks, and any other code that
is generated.
    
## Technology Stack

### Database

For Database we use PostgreSQL.

Schema is defined `internal/repositories/postgres/migrations`.

SQLC is used to generate Go code from SQL queries. The generated code is placed in `internal/repositories/postgres/pgsqlc/queries.sql`.

## Architecture

### Code

The system uses 3 layers:

- **Transport Layer**: This is the entry point for the system. It handles incoming requests and routes them to the appropriate service. This is the only layer that connects to the real world.
- **Service Layer**: This layer contains the business logic of the system. It processes requests from the transport layer and interacts with the data layer to perform operations.
- **Repository Layer**: This layer is responsible for data storage and retrieval. It interacts with the database and provides an interface for the service layer to perform CRUD operations.

#### Layer boundaries

All layer boundaries will export public methods using the Request/Response structs. Also, a `context.Context` is always
received as the first argument in all public methods to allow for cancellation and timeouts. Also, in a general manner, 
requests are pointers and responses are values. An error should always be returned as the last argument in all boundary 

#### Repository Layer

Generally, every table will have its own repository implementation.

The repository layer will contain methods for CRUD operations and any specific queries needed for the application.

Create and Update methods should be specific and not generic. For example, if you have a `User` table, the `Create` 
method from the `UserRespository` struct should be used to create a user, and the `UpdatePassword` method should be used
to update the password of a user. This is to ensure that the methods are clear and specific to the entity they are
working with. We should avoid generic methods like `Update` that will take nullable fields. However, they are not
forbidden, when fit for the use case. A good example is an admin user update may use a generic `AdminUpdate` method that
take nullable fields.

Some repositories will need to support transactions. In this case, the repository will have a `WithTx` method that
will return a new instance of the repo with the given transaction as queries.

#### Service Layer

The service layer is split into multiple smaller service packages, each responsible for a specific domain or use.

The service layer code will be placed in `internal/services/`.

The service layer will receive requests from the transport layer and will use the repository layer or any other entity
needed to perform the the operation (for example adapters).

The service layer should validate the requests and return appropriate responses.

The responsability of validating the request is from the service layer, not the transport layer. For example, a transport
layer would pass an UUID as a string, and the service layer should validate that the string is a valid UUID and parse it
for futher use.

The validation methods names should be validate{Operation}Request, for example `validateCreateRequest`.

#### Transport Layer

TODO.

#### Code Style

- Avoid unnecessary comments, except when logic is complex.
